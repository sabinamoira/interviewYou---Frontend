/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Component, ContentChildren, EventEmitter, forwardRef, HostBinding, HostListener, Input, Output, QueryList, TemplateRef, ViewEncapsulation } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { OptionComponent } from './option/option.component';
import { defer, merge, Subject } from 'rxjs';
import { startWith, switchMap, takeUntil } from 'rxjs/operators';
/**
 * Select component intended to mimic the behaviour of the native select element.
 */
export class SelectComponent {
    constructor() {
        /**
         * @hidden
         */
        this.fdDropdownClass = true;
        /**
         * Whether the select component is disabled.
         */
        this.disabled = false;
        /**
         * Open state of the select.
         */
        this.isOpen = false;
        /**
         * Whether the select is in compact mode.
         */
        this.compact = false;
        /**
         * Popper.js options of the popover.
         */
        this.popperOptions = {
            placement: 'bottom-start',
            modifiers: {
                preventOverflow: {
                    enabled: true,
                    escapeWithReference: true,
                    boundariesElement: 'scrollParent'
                }
            }
        };
        /**
         * Preset options for the popover body width.
         * * `at-least` will apply a minimum width to the body equivalent to the width of the control.
         * * `equal` will apply a width to the body equivalent to the width of the control.
         * * Leave blank for no effect.
         */
        this.fillControlMode = 'at-least';
        /**
         * Event emitted when the popover open state changes.
         */
        this.isOpenChange = new EventEmitter();
        /**
         * Event emitted when the selected value of the select changes.
         */
        this.valueChange = new EventEmitter();
        /**
         * Subject triggered when the component is destroyed.
         */
        this.destroy$ = new Subject();
        /**
         * Observable triggered when an option has its selectedChange event fire.
         */
        this.optionsStatusChanges = (/** @type {?} */ (defer((/**
         * @return {?}
         */
        () => {
            /** @type {?} */
            const options = this.options;
            if (options) {
                return options.changes.pipe(startWith(options), switchMap((/**
                 * @return {?}
                 */
                () => merge(...options.map((/**
                 * @param {?} option
                 * @return {?}
                 */
                option => option.selectedChange))))));
            }
        }))));
        /**
         * @hidden
         */
        this.onChange = (/**
         * @return {?}
         */
        () => { });
        /**
         * @hidden
         */
        this.onTouched = (/**
         * @return {?}
         */
        () => { });
    }
    /**
     * @hidden
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.value) {
            setTimeout((/**
             * @return {?}
             */
            () => {
                if (this.value) {
                    this.selectValue(this.value, false);
                }
            }));
        }
    }
    /**
     * @hidden
     * @return {?}
     */
    ngAfterContentInit() {
        // If the observable state changes, reset the options and initialize selection.
        this.options.changes.pipe(startWith(null), takeUntil(this.destroy$)).subscribe((/**
         * @return {?}
         */
        () => {
            this.resetOptions();
            this.initSelection();
        }));
    }
    /**
     * @hidden
     * @return {?}
     */
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
    }
    /**
     * Toggles the open state of the select.
     * @return {?}
     */
    toggle() {
        if (this.isOpen && !this.disabled) {
            this.close();
        }
        else {
            this.open();
        }
    }
    /**
     * Opens the select popover body.
     * @return {?}
     */
    open() {
        if (!this.isOpen && !this.disabled) {
            this.isOpen = true;
            this.isOpenChange.emit(this.isOpen);
        }
    }
    /**
     * Closes the select popover body.
     * @return {?}
     */
    close() {
        if (this.isOpen && !this.disabled) {
            this.isOpen = false;
            this.isOpenChange.emit(this.isOpen);
        }
    }
    /**
     * @hidden
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onChange = fn;
    }
    /**
     * @hidden
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    /**
     * @hidden
     * @param {?} isDisabled
     * @return {?}
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    /**
     * @hidden
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if (this.options) {
            this.selectValue(value, false);
        }
        else {
            // Defer the selection of the value to support forms
            Promise.resolve().then((/**
             * @return {?}
             */
            () => {
                if (this.options) {
                    this.selectValue(value, false);
                }
            }));
        }
    }
    /**
     * Returns the current trigger value if there is a selected option. Otherwise, returns the placeholder.
     * @return {?}
     */
    get triggerValue() {
        return this.selected ? this.selected.viewValueText : this.placeholder;
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    keydownHandler(event) {
        switch (event.code) {
            case ('ArrowUp'): {
                event.preventDefault();
                this.decrementFocused();
                break;
            }
            case ('ArrowDown'): {
                event.preventDefault();
                this.incrementFocused();
                break;
            }
        }
    }
    /**
     * Selects an option by option component reference. Preferred method of selection.
     * @private
     * @param {?} option The option component to search for.
     * @param {?=} fireEvents Whether to fire change events.
     * @return {?}
     */
    selectOption(option, fireEvents = true) {
        if (!this.isOptionActive(option)) {
            if (this.selected) {
                this.selected.setSelected(false, false);
            }
            option.setSelected(true, false);
            this.selected = option;
            this.updateValue(fireEvents);
            this.close();
            return option;
        }
        return;
    }
    /**
     * Selects an option by value. If two components have the same value, the first one found is selected.
     * Recommend using selectOption generally.
     * @private
     * @param {?} value Value to search for.
     * @param {?=} fireEvents Whether to fire change events.
     * @return {?}
     */
    selectValue(value, fireEvents = true) {
        /** @type {?} */
        const matchOption = this.options.find((/**
         * @param {?} option
         * @return {?}
         */
        (option) => {
            return option.value != null && option.value === value;
        }));
        // If not match is found, set everything to null
        // This is mostly only for cases where a user removes an active option
        if (!matchOption) {
            this.unselectOptions();
            return;
        }
        // If match is found, select the new value
        if (matchOption && !this.isOptionActive(matchOption)) {
            if (this.selected) {
                this.selected.setSelected(false, false);
            }
            matchOption.setSelected(true, false);
            this.selected = matchOption;
            this.updateValue(fireEvents);
            this.close();
        }
        return matchOption;
    }
    /**
     * Updates the value parameter with optional events.
     * @private
     * @param {?=} fireEvents If true, function fires valueChange, onChange and onTouched events.
     * @return {?}
     */
    updateValue(fireEvents = true) {
        this.value = this.selected.value;
        if (fireEvents) {
            this.valueChange.emit(this.value);
            this.onChange(this.value);
            this.onTouched();
        }
    }
    /**
     * Function used to reset the options state.
     * @private
     * @return {?}
     */
    resetOptions() {
        // Create observable that fires when the options change or the component is destroyed.
        /** @type {?} */
        const destroyCurrentObs = merge(this.options.changes, this.destroy$);
        // Subscribe to observable defined in component properties which fires when an option is clicked.
        // Destroy if the observable defined above triggers.
        this.optionsStatusChanges.pipe(takeUntil(destroyCurrentObs)).subscribe((/**
         * @param {?} instance
         * @return {?}
         */
        (instance) => {
            this.selectOption(instance);
        }));
    }
    /**
     * Selection initialization when a change occurs in options.
     * @private
     * @return {?}
     */
    initSelection() {
        if (this.value) {
            this.selected = undefined;
            this.selectValue(this.value, false);
        }
    }
    /**
     * Function that tests whether the tested option is currently selected.
     * @private
     * @param {?} option Option to test against the selected option.
     * @return {?}
     */
    isOptionActive(option) {
        return option && this.selected && option === this.selected;
    }
    /**
     * Method that focuses the next option in the list, or the first one if the last one is currently focused.
     * @private
     * @return {?}
     */
    incrementFocused() {
        // Get active focused element
        /** @type {?} */
        const activeElement = document.activeElement;
        // Get corresponding option element to the above
        /** @type {?} */
        const correspondingOption = this.options.find((/**
         * @param {?} option
         * @return {?}
         */
        option => {
            return option.getHtmlElement() === activeElement;
        }));
        if (correspondingOption) {
            /** @type {?} */
            const arrayOptions = this.options.toArray();
            /** @type {?} */
            const index = arrayOptions.indexOf(correspondingOption);
            // If active option is the last option, focus the first one
            // Otherwise, focus the next option.
            if (index === this.options.length - 1) {
                arrayOptions[0].focus();
            }
            else {
                arrayOptions[index + 1].focus();
            }
        }
        else if (this.options) {
            this.options.first.focus();
        }
    }
    /**
     * Method that focuses the previous option in the list, or the last one if the last one is currently focused.
     * @private
     * @return {?}
     */
    decrementFocused() {
        // Get active focused element
        /** @type {?} */
        const activeElement = document.activeElement;
        // Get corresponding option element to the above
        /** @type {?} */
        const correspondingOption = this.options.find((/**
         * @param {?} option
         * @return {?}
         */
        option => {
            return option.getHtmlElement() === activeElement;
        }));
        // If active option is the first option, focus the last one
        // Otherwise, focus the previous option.
        if (correspondingOption) {
            /** @type {?} */
            const arrayOptions = this.options.toArray();
            /** @type {?} */
            const index = arrayOptions.indexOf(correspondingOption);
            if (index === 0) {
                arrayOptions[this.options.length - 1].focus();
            }
            else {
                arrayOptions[index - 1].focus();
            }
        }
        else if (this.options) {
            this.options.first.focus();
        }
    }
    /**
     * Method used to handle cases where a user removes the currently active option.
     * The timeout is required because this can happen after the view has been checked.
     * @private
     * @return {?}
     */
    unselectOptions() {
        setTimeout((/**
         * @return {?}
         */
        () => {
            if (this.selected) {
                this.selected.setSelected(false, false);
            }
            this.selected = undefined;
            this.value = undefined;
            this.valueChange.emit(undefined);
            this.onChange(undefined);
        }));
    }
}
SelectComponent.decorators = [
    { type: Component, args: [{
                selector: 'fd-select',
                template: "<fd-popover [(isOpen)]=\"isOpen\"\n            (isOpenChange)=\"isOpenChange.emit($event)\"\n            [options]=\"popperOptions\"\n            [fillControlMode]=\"fillControlMode\"\n            [appendTo]=\"appendTo\"\n            class=\"fd-select-popover-custom\">\n    <fd-popover-control>\n        <ng-container *ngIf=\"triggerTemplate\">\n            <ng-container *ngTemplateOutlet=\"triggerTemplate; context: {$implicit: this}\"></ng-container>\n        </ng-container>\n        <ng-container *ngIf=\"!triggerTemplate\">\n            <button class=\"fd-dropdown__control fd-button fd-select-button-custom\"\n                    aria-haspopup=\"true\"\n                    [ngClass]=\"{'fd-button--compact': compact}\"\n                    [attr.aria-expanded]=\"isOpen\"\n                    [disabled]=\"disabled\">\n                <span class=\"fd-select-text-custom\">{{triggerValue}}</span>\n            </button>\n        </ng-container>\n    </fd-popover-control>\n    <fd-popover-body>\n        <ng-content></ng-content>\n    </fd-popover-body>\n</fd-popover>\n",
                encapsulation: ViewEncapsulation.None,
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => SelectComponent)),
                        multi: true
                    }
                ],
                host: {
                    '[class.fd-select-custom]': 'true',
                    'role': 'listbox',
                },
                styles: [".fd-select-custom{display:inline-block;width:100%}.fd-select-custom .fd-select-popover-custom{display:block}.fd-select-custom .fd-select-popover-custom fd-popover-container{min-width:100%;overflow:auto}.fd-select-custom .fd-select-button-custom{display:flex;align-items:flex-end;justify-content:space-between}.fd-select-custom .fd-select-button-custom::after{flex-shrink:0;margin-top:0}.fd-select-custom .fd-select-text-custom{text-overflow:ellipsis;white-space:nowrap;overflow-x:hidden}"]
            }] }
];
SelectComponent.propDecorators = {
    fdDropdownClass: [{ type: HostBinding, args: ['class.fd-dropdown',] }],
    options: [{ type: ContentChildren, args: [OptionComponent, { descendants: true },] }],
    disabled: [{ type: Input }],
    placeholder: [{ type: Input }],
    isOpen: [{ type: Input }],
    value: [{ type: Input }],
    compact: [{ type: Input }],
    popperOptions: [{ type: Input }],
    fillControlMode: [{ type: Input }],
    triggerTemplate: [{ type: Input }],
    appendTo: [{ type: Input }],
    isOpenChange: [{ type: Output }],
    valueChange: [{ type: Output }],
    keydownHandler: [{ type: HostListener, args: ['keydown', ['$event'],] }]
};
if (false) {
    /**
     * @hidden
     * @type {?}
     */
    SelectComponent.prototype.fdDropdownClass;
    /**
     * @hidden
     * @type {?}
     */
    SelectComponent.prototype.options;
    /**
     * Whether the select component is disabled.
     * @type {?}
     */
    SelectComponent.prototype.disabled;
    /**
     * Placeholder for the select. Appears in the triggerbox if no option is selected.
     * @type {?}
     */
    SelectComponent.prototype.placeholder;
    /**
     * Open state of the select.
     * @type {?}
     */
    SelectComponent.prototype.isOpen;
    /**
     * Current value of the selected option.
     * @type {?}
     */
    SelectComponent.prototype.value;
    /**
     * Whether the select is in compact mode.
     * @type {?}
     */
    SelectComponent.prototype.compact;
    /**
     * Popper.js options of the popover.
     * @type {?}
     */
    SelectComponent.prototype.popperOptions;
    /**
     * Preset options for the popover body width.
     * * `at-least` will apply a minimum width to the body equivalent to the width of the control.
     * * `equal` will apply a width to the body equivalent to the width of the control.
     * * Leave blank for no effect.
     * @type {?}
     */
    SelectComponent.prototype.fillControlMode;
    /**
     * Template with which to display the trigger box.
     * @type {?}
     */
    SelectComponent.prototype.triggerTemplate;
    /**
     * The element to which the popover should be appended.
     * @type {?}
     */
    SelectComponent.prototype.appendTo;
    /**
     * Event emitted when the popover open state changes.
     * @type {?}
     */
    SelectComponent.prototype.isOpenChange;
    /**
     * Event emitted when the selected value of the select changes.
     * @type {?}
     */
    SelectComponent.prototype.valueChange;
    /**
     * Current selected option component reference.
     * @type {?}
     * @private
     */
    SelectComponent.prototype.selected;
    /**
     * Subject triggered when the component is destroyed.
     * @type {?}
     * @private
     */
    SelectComponent.prototype.destroy$;
    /**
     * Observable triggered when an option has its selectedChange event fire.
     * @type {?}
     * @private
     */
    SelectComponent.prototype.optionsStatusChanges;
    /**
     * @hidden
     * @type {?}
     */
    SelectComponent.prototype.onChange;
    /**
     * @hidden
     * @type {?}
     */
    SelectComponent.prototype.onTouched;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VsZWN0LmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2Z1bmRhbWVudGFsLW5neC8iLCJzb3VyY2VzIjpbImxpYi9zZWxlY3Qvc2VsZWN0LmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBTyxFQUVILFNBQVMsRUFDVCxlQUFlLEVBQ2YsWUFBWSxFQUFFLFVBQVUsRUFBRSxXQUFXLEVBQUUsWUFBWSxFQUNuRCxLQUFLLEVBQ0wsTUFBTSxFQUNOLFNBQVMsRUFBaUIsV0FBVyxFQUNyQyxpQkFBaUIsRUFDcEIsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUF3QixpQkFBaUIsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ3pFLE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSwyQkFBMkIsQ0FBQztBQUM1RCxPQUFPLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBYyxPQUFPLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDekQsT0FBTyxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7Ozs7QUF3QmpFLE1BQU0sT0FBTyxlQUFlO0lBakI1Qjs7OztRQXFCSSxvQkFBZSxHQUFZLElBQUksQ0FBQzs7OztRQVFoQyxhQUFRLEdBQVksS0FBSyxDQUFDOzs7O1FBUTFCLFdBQU0sR0FBWSxLQUFLLENBQUM7Ozs7UUFReEIsWUFBTyxHQUFZLEtBQUssQ0FBQzs7OztRQUl6QixrQkFBYSxHQUFrQjtZQUMzQixTQUFTLEVBQUUsY0FBYztZQUN6QixTQUFTLEVBQUU7Z0JBQ1AsZUFBZSxFQUFFO29CQUNiLE9BQU8sRUFBRSxJQUFJO29CQUNiLG1CQUFtQixFQUFFLElBQUk7b0JBQ3pCLGlCQUFpQixFQUFFLGNBQWM7aUJBQ3BDO2FBQ0o7U0FDSixDQUFDOzs7Ozs7O1FBU0Ysb0JBQWUsR0FBb0IsVUFBVSxDQUFDOzs7O1FBWXJDLGlCQUFZLEdBQ2YsSUFBSSxZQUFZLEVBQVcsQ0FBQzs7OztR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QUUsU0FBUztpQkFDcEI7O2FBQ0o7Ozs4QkFJSSxXQUFXLFNBQUMsbUJBQW1CO3NCQUkvQixlQUFlLFNBQUMsZUFBZSxFQUFFLEVBQUUsV0FBVyxFQUFFLElBQUksRUFBRTt1QkFJdEQsS0FBSzswQkFJTCxLQUFLO3FCQUlMLEtBQUs7b0JBSUwsS0FBSztzQkFJTCxLQUFLOzRCQUlMLEtBQUs7OEJBa0JMLEtBQUs7OEJBSUwsS0FBSzt1QkFJTCxLQUFLOzJCQUlMLE1BQU07MEJBS04sTUFBTTs2QkFrSE4sWUFBWSxTQUFDLFNBQVMsRUFBRSxDQUFDLFFBQVEsQ0FBQzs7Ozs7OztJQWpMbkMsMENBQ2dDOzs7OztJQUdoQyxrQ0FDb0M7Ozs7O0lBR3BDLG1DQUMwQjs7Ozs7SUFHMUIsc0NBQ29COzs7OztJQUdwQixpQ0FDd0I7Ozs7O0lBR3hCLGdDQUNXOzs7OztJQUdYLGtDQUN5Qjs7Ozs7SUFHekIsd0NBVUU7Ozs7Ozs7O0lBUUYsMENBQzhDOzs7OztJQUc5QywwQ0FDa0M7Ozs7O0lBR2xDLG1DQUMrQjs7Ozs7SUFHL0IsdUNBRWtDOzs7OztJQUdsQyxzQ0FFOEI7Ozs7OztJQUc5QixtQ0FBa0M7Ozs7OztJQUdsQyxtQ0FBK0Q7Ozs7OztJQUcvRCwrQ0FRa0M7Ozs7O0lBR2xDLG1DQUE4Qjs7Ozs7SUFHOUIsb0NBQStCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgICBBZnRlckNvbnRlbnRJbml0LFxuICAgIENvbXBvbmVudCxcbiAgICBDb250ZW50Q2hpbGRyZW4sXG4gICAgRXZlbnRFbWl0dGVyLCBmb3J3YXJkUmVmLCBIb3N0QmluZGluZywgSG9zdExpc3RlbmVyLFxuICAgIElucHV0LCBPbkNoYW5nZXMsIE9uRGVzdHJveSxcbiAgICBPdXRwdXQsXG4gICAgUXVlcnlMaXN0LCBTaW1wbGVDaGFuZ2VzLCBUZW1wbGF0ZVJlZixcbiAgICBWaWV3RW5jYXBzdWxhdGlvblxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBOR19WQUxVRV9BQ0NFU1NPUiB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IE9wdGlvbkNvbXBvbmVudCB9IGZyb20gJy4vb3B0aW9uL29wdGlvbi5jb21wb25lbnQnO1xuaW1wb3J0IHsgZGVmZXIsIG1lcmdlLCBPYnNlcnZhYmxlLCBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBzdGFydFdpdGgsIHN3aXRjaE1hcCwgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgUG9wcGVyT3B0aW9ucyB9IGZyb20gJ3BvcHBlci5qcyc7XG5pbXBvcnQgeyBQb3BvdmVyRmlsbE1vZGUgfSBmcm9tICcuLi9wb3BvdmVyL3BvcG92ZXItZGlyZWN0aXZlL3BvcG92ZXIuZGlyZWN0aXZlJztcblxuLyoqXG4gKiBTZWxlY3QgY29tcG9uZW50IGludGVuZGVkIHRvIG1pbWljIHRoZSBiZWhhdmlvdXIgb2YgdGhlIG5hdGl2ZSBzZWxlY3QgZWxlbWVudC5cbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdmZC1zZWxlY3QnLFxuICAgIHRlbXBsYXRlVXJsOiAnLi9zZWxlY3QuY29tcG9uZW50Lmh0bWwnLFxuICAgIHN0eWxlVXJsczogWycuL3NlbGVjdC5jb21wb25lbnQuc2NzcyddLFxuICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gICAgcHJvdmlkZXJzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgICAgICAgICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gU2VsZWN0Q29tcG9uZW50KSxcbiAgICAgICAgICAgIG11bHRpOiB0cnVlXG4gICAgICAgIH1cbiAgICBdLFxuICAgIGhvc3Q6IHtcbiAgICAgICAgJ1tjbGFzcy5mZC1zZWxlY3QtY3VzdG9tXSc6ICd0cnVlJyxcbiAgICAgICAgJ3JvbGUnOiAnbGlzdGJveCcsXG4gICAgfVxufSlcbmV4cG9ydCBjbGFzcyBTZWxlY3RDb21wb25lbnQgaW1wbGVtZW50cyBPbkNoYW5nZXMsIEFmdGVyQ29udGVudEluaXQsIE9uRGVzdHJveSwgQ29udHJvbFZhbHVlQWNjZXNzb3Ige1xuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmZkLWRyb3Bkb3duJylcbiAgICBmZERyb3Bkb3duQ2xhc3M6IGJvb2xlYW4gPSB0cnVlO1xuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBAQ29udGVudENoaWxkcmVuKE9wdGlvbkNvbXBvbmVudCwgeyBkZXNjZW5kYW50czogdHJ1ZSB9KVxuICAgIG9wdGlvbnM6IFF1ZXJ5TGlzdDxPcHRpb25Db21wb25lbnQ+O1xuXG4gICAgLyoqIFdoZXRoZXIgdGhlIHNlbGVjdCBjb21wb25lbnQgaXMgZGlzYWJsZWQuICovXG4gICAgQElucHV0KClcbiAgICBkaXNhYmxlZDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgLyoqIFBsYWNlaG9sZGVyIGZvciB0aGUgc2VsZWN0LiBBcHBlYXJzIGluIHRoZSB0cmlnZ2VyYm94IGlmIG5vIG9wdGlvbiBpcyBzZWxlY3RlZC4gKi9cbiAgICBASW5wdXQoKVxuICAgIHBsYWNlaG9sZGVyOiBzdHJpbmc7XG5cbiAgICAvKiogT3BlbiBzdGF0ZSBvZiB0aGUgc2VsZWN0LiAqL1xuICAgIEBJbnB1dCgpXG4gICAgaXNPcGVuOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvKiogQ3VycmVudCB2YWx1ZSBvZiB0aGUgc2VsZWN0ZWQgb3B0aW9uLiAqL1xuICAgIEBJbnB1dCgpXG4gICAgdmFsdWU6IGFueTtcblxuICAgIC8qKiBXaGV0aGVyIHRoZSBzZWxlY3QgaXMgaW4gY29tcGFjdCBtb2RlLiAqL1xuICAgIEBJbnB1dCgpXG4gICAgY29tcGFjdDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgLyoqIFBvcHBlci5qcyBvcHRpb25zIG9mIHRoZSBwb3BvdmVyLiAqL1xuICAgIEBJbnB1dCgpXG4gICAgcG9wcGVyT3B0aW9uczogUG9wcGVyT3B0aW9ucyA9IHtcbiAgICAgICAgcGxhY2VtZW50OiAnYm90dG9tLXN0YXJ0JyxcbiAgICAgICAgbW9kaWZpZXJzOiB7XG4gICAgICAgICAgICBwcmV2ZW50T3ZlcmZsb3c6IHtcbiAgICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgIGVzY2FwZVdpdGhSZWZlcmVuY2U6IHRydWUsXG4gICAgICAgICAgICAgICAgYm91bmRhcmllc0VsZW1lbnQ6ICdzY3JvbGxQYXJlbnQnXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUHJlc2V0IG9wdGlvbnMgZm9yIHRoZSBwb3BvdmVyIGJvZHkgd2lkdGguXG4gICAgICogKiBgYXQtbGVhc3RgIHdpbGwgYXBwbHkgYSBtaW5pbXVtIHdpZHRoIHRvIHRoZSBib2R5IGVxdWl2YWxlbnQgdG8gdGhlIHdpZHRoIG9mIHRoZSBjb250cm9sLlxuICAgICAqICogYGVxdWFsYCB3aWxsIGFwcGx5IGEgd2lkdGggdG8gdGhlIGJvZHkgZXF1aXZhbGVudCB0byB0aGUgd2lkdGggb2YgdGhlIGNvbnRyb2wuXG4gICAgICogKiBMZWF2ZSBibGFuayBmb3Igbm8gZWZmZWN0LlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgZmlsbENvbnRyb2xNb2RlOiBQb3BvdmVyRmlsbE1vZGUgPSAnYXQtbGVhc3QnO1xuXG4gICAgLyoqIFRlbXBsYXRlIHdpdGggd2hpY2ggdG8gZGlzcGxheSB0aGUgdHJpZ2dlciBib3guICovXG4gICAgQElucHV0KClcbiAgICB0cmlnZ2VyVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG5cbiAgICAvKiogVGhlIGVsZW1lbnQgdG8gd2hpY2ggdGhlIHBvcG92ZXIgc2hvdWxkIGJlIGFwcGVuZGVkLiAqL1xuICAgIEBJbnB1dCgpXG4gICAgYXBwZW5kVG86IEhUTUxFbGVtZW50IHwgJ2JvZHknO1xuXG4gICAgLyoqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgcG9wb3ZlciBvcGVuIHN0YXRlIGNoYW5nZXMuICovXG4gICAgQE91dHB1dCgpXG4gICAgcmVhZG9ubHkgaXNPcGVuQ2hhbmdlOiBFdmVudEVtaXR0ZXI8Ym9vbGVhbj5cbiAgICAgICAgPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KCk7XG5cbiAgICAvKiogRXZlbnQgZW1pdHRlZCB3aGVuIHRoZSBzZWxlY3RlZCB2YWx1ZSBvZiB0aGUgc2VsZWN0IGNoYW5nZXMuICovXG4gICAgQE91dHB1dCgpXG4gICAgcmVhZG9ubHkgdmFsdWVDaGFuZ2U6IEV2ZW50RW1pdHRlcjxhbnk+XG4gICAgICAgID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG5cbiAgICAvKiogQ3VycmVudCBzZWxlY3RlZCBvcHRpb24gY29tcG9uZW50IHJlZmVyZW5jZS4gKi9cbiAgICBwcml2YXRlIHNlbGVjdGVkOiBPcHRpb25Db21wb25lbnQ7XG5cbiAgICAvKiogU3ViamVjdCB0cmlnZ2VyZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIGRlc3Ryb3llZC4gKi9cbiAgICBwcml2YXRlIHJlYWRvbmx5IGRlc3Ryb3kkOiBTdWJqZWN0PHZvaWQ+ID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcblxuICAgIC8qKiBPYnNlcnZhYmxlIHRyaWdnZXJlZCB3aGVuIGFuIG9wdGlvbiBoYXMgaXRzIHNlbGVjdGVkQ2hhbmdlIGV2ZW50IGZpcmUuICovXG4gICAgcHJpdmF0ZSByZWFkb25seSBvcHRpb25zU3RhdHVzQ2hhbmdlczogT2JzZXJ2YWJsZTxPcHRpb25Db21wb25lbnQ+ID0gZGVmZXIoKCkgPT4ge1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuY2hhbmdlcy5waXBlKFxuICAgICAgICAgICAgICAgIHN0YXJ0V2l0aChvcHRpb25zKSxcbiAgICAgICAgICAgICAgICBzd2l0Y2hNYXAoKCkgPT4gbWVyZ2UoLi4ub3B0aW9ucy5tYXAob3B0aW9uID0+IG9wdGlvbi5zZWxlY3RlZENoYW5nZSkpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH0pIGFzIE9ic2VydmFibGU8T3B0aW9uQ29tcG9uZW50PjtcblxuICAgIC8qKiBAaGlkZGVuICovXG4gICAgb25DaGFuZ2U6IEZ1bmN0aW9uID0gKCkgPT4ge307XG5cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIG9uVG91Y2hlZDogRnVuY3Rpb24gPSAoKSA9PiB7fTtcblxuICAgIC8qKiBAaGlkZGVuICovXG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IHZvaWQge1xuICAgICAgICBpZiAoY2hhbmdlcy52YWx1ZSkge1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RWYWx1ZSh0aGlzLnZhbHVlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIG5nQWZ0ZXJDb250ZW50SW5pdCgpOiB2b2lkIHtcblxuICAgICAgICAvLyBJZiB0aGUgb2JzZXJ2YWJsZSBzdGF0ZSBjaGFuZ2VzLCByZXNldCB0aGUgb3B0aW9ucyBhbmQgaW5pdGlhbGl6ZSBzZWxlY3Rpb24uXG4gICAgICAgIHRoaXMub3B0aW9ucy5jaGFuZ2VzLnBpcGUoc3RhcnRXaXRoKG51bGwpLCB0YWtlVW50aWwodGhpcy5kZXN0cm95JCkpLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlc2V0T3B0aW9ucygpO1xuICAgICAgICAgICAgdGhpcy5pbml0U2VsZWN0aW9uKCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuICovXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZGVzdHJveSQubmV4dCgpO1xuICAgICAgICB0aGlzLmRlc3Ryb3kkLmNvbXBsZXRlKCk7XG4gICAgfVxuXG4gICAgLyoqIFRvZ2dsZXMgdGhlIG9wZW4gc3RhdGUgb2YgdGhlIHNlbGVjdC4gKi9cbiAgICB0b2dnbGUoKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLmlzT3BlbiAmJiAhdGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5vcGVuKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogT3BlbnMgdGhlIHNlbGVjdCBwb3BvdmVyIGJvZHkuICovXG4gICAgb3BlbigpOiB2b2lkIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzT3BlbiAmJiAhdGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5pc09wZW4gPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5pc09wZW5DaGFuZ2UuZW1pdCh0aGlzLmlzT3Blbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogQ2xvc2VzIHRoZSBzZWxlY3QgcG9wb3ZlciBib2R5LiAqL1xuICAgIGNsb3NlKCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5pc09wZW4gJiYgIXRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaXNPcGVuID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmlzT3BlbkNoYW5nZS5lbWl0KHRoaXMuaXNPcGVuKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuICovXG4gICAgcmVnaXN0ZXJPbkNoYW5nZShmbjogYW55KTogdm9pZCB7XG4gICAgICAgIHRoaXMub25DaGFuZ2UgPSBmbjtcbiAgICB9XG5cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIHJlZ2lzdGVyT25Ub3VjaGVkKGZuOiBhbnkpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5vblRvdWNoZWQgPSBmbjtcbiAgICB9XG5cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIHNldERpc2FibGVkU3RhdGUoaXNEaXNhYmxlZDogYm9vbGVhbik6IHZvaWQge1xuICAgICAgICB0aGlzLmRpc2FibGVkID0gaXNEaXNhYmxlZDtcbiAgICB9XG5cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIHdyaXRlVmFsdWUodmFsdWU6IGFueSk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdFZhbHVlKHZhbHVlLCBmYWxzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBEZWZlciB0aGUgc2VsZWN0aW9uIG9mIHRoZSB2YWx1ZSB0byBzdXBwb3J0IGZvcm1zXG4gICAgICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0VmFsdWUodmFsdWUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBSZXR1cm5zIHRoZSBjdXJyZW50IHRyaWdnZXIgdmFsdWUgaWYgdGhlcmUgaXMgYSBzZWxlY3RlZCBvcHRpb24uIE90aGVyd2lzZSwgcmV0dXJucyB0aGUgcGxhY2Vob2xkZXIuICovXG4gICAgZ2V0IHRyaWdnZXJWYWx1ZSgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3RlZCA/IHRoaXMuc2VsZWN0ZWQudmlld1ZhbHVlVGV4dCA6IHRoaXMucGxhY2Vob2xkZXI7XG4gICAgfVxuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBASG9zdExpc3RlbmVyKCdrZXlkb3duJywgWyckZXZlbnQnXSlcbiAgICBrZXlkb3duSGFuZGxlcihldmVudDogS2V5Ym9hcmRFdmVudCk6IHZvaWQge1xuICAgICAgICBzd2l0Y2ggKGV2ZW50LmNvZGUpIHtcbiAgICAgICAgICAgIGNhc2UgKCdBcnJvd1VwJyk6IHtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGVjcmVtZW50Rm9jdXNlZCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAoJ0Fycm93RG93bicpOiB7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmluY3JlbWVudEZvY3VzZWQoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlbGVjdHMgYW4gb3B0aW9uIGJ5IG9wdGlvbiBjb21wb25lbnQgcmVmZXJlbmNlLiBQcmVmZXJyZWQgbWV0aG9kIG9mIHNlbGVjdGlvbi5cbiAgICAgKiBAcGFyYW0gb3B0aW9uIFRoZSBvcHRpb24gY29tcG9uZW50IHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHBhcmFtIGZpcmVFdmVudHMgV2hldGhlciB0byBmaXJlIGNoYW5nZSBldmVudHMuXG4gICAgICovXG4gICAgcHJpdmF0ZSBzZWxlY3RPcHRpb24ob3B0aW9uOiBPcHRpb25Db21wb25lbnQsIGZpcmVFdmVudHM6IGJvb2xlYW4gPSB0cnVlKTogT3B0aW9uQ29tcG9uZW50IHwgdW5kZWZpbmVkIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzT3B0aW9uQWN0aXZlKG9wdGlvbikpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZC5zZXRTZWxlY3RlZChmYWxzZSwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3B0aW9uLnNldFNlbGVjdGVkKHRydWUsIGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWQgPSBvcHRpb247XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlKGZpcmVFdmVudHMpO1xuICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VsZWN0cyBhbiBvcHRpb24gYnkgdmFsdWUuIElmIHR3byBjb21wb25lbnRzIGhhdmUgdGhlIHNhbWUgdmFsdWUsIHRoZSBmaXJzdCBvbmUgZm91bmQgaXMgc2VsZWN0ZWQuXG4gICAgICogUmVjb21tZW5kIHVzaW5nIHNlbGVjdE9wdGlvbiBnZW5lcmFsbHkuXG4gICAgICogQHBhcmFtIHZhbHVlIFZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHBhcmFtIGZpcmVFdmVudHMgV2hldGhlciB0byBmaXJlIGNoYW5nZSBldmVudHMuXG4gICAgICovXG4gICAgcHJpdmF0ZSBzZWxlY3RWYWx1ZSh2YWx1ZTogYW55LCBmaXJlRXZlbnRzOiBib29sZWFuID0gdHJ1ZSk6IE9wdGlvbkNvbXBvbmVudCB8IHVuZGVmaW5lZCB7XG4gICAgICAgIGNvbnN0IG1hdGNoT3B0aW9uID0gdGhpcy5vcHRpb25zLmZpbmQoKG9wdGlvbjogT3B0aW9uQ29tcG9uZW50KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9uLnZhbHVlICE9IG51bGwgJiYgb3B0aW9uLnZhbHVlID09PSB2YWx1ZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gSWYgbm90IG1hdGNoIGlzIGZvdW5kLCBzZXQgZXZlcnl0aGluZyB0byBudWxsXG4gICAgICAgIC8vIFRoaXMgaXMgbW9zdGx5IG9ubHkgZm9yIGNhc2VzIHdoZXJlIGEgdXNlciByZW1vdmVzIGFuIGFjdGl2ZSBvcHRpb25cbiAgICAgICAgaWYgKCFtYXRjaE9wdGlvbikge1xuICAgICAgICAgICAgdGhpcy51bnNlbGVjdE9wdGlvbnMoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIG1hdGNoIGlzIGZvdW5kLCBzZWxlY3QgdGhlIG5ldyB2YWx1ZVxuICAgICAgICBpZiAobWF0Y2hPcHRpb24gJiYgIXRoaXMuaXNPcHRpb25BY3RpdmUobWF0Y2hPcHRpb24pKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWQuc2V0U2VsZWN0ZWQoZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1hdGNoT3B0aW9uLnNldFNlbGVjdGVkKHRydWUsIGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWQgPSBtYXRjaE9wdGlvbjtcblxuICAgICAgICAgICAgdGhpcy51cGRhdGVWYWx1ZShmaXJlRXZlbnRzKTtcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtYXRjaE9wdGlvbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSB2YWx1ZSBwYXJhbWV0ZXIgd2l0aCBvcHRpb25hbCBldmVudHMuXG4gICAgICogQHBhcmFtIGZpcmVFdmVudHMgSWYgdHJ1ZSwgZnVuY3Rpb24gZmlyZXMgdmFsdWVDaGFuZ2UsIG9uQ2hhbmdlIGFuZCBvblRvdWNoZWQgZXZlbnRzLlxuICAgICAqL1xuICAgIHByaXZhdGUgdXBkYXRlVmFsdWUoZmlyZUV2ZW50czogYm9vbGVhbiA9IHRydWUpOiB2b2lkIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMuc2VsZWN0ZWQudmFsdWU7XG4gICAgICAgIGlmIChmaXJlRXZlbnRzKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlQ2hhbmdlLmVtaXQodGhpcy52YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLm9uQ2hhbmdlKHRoaXMudmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5vblRvdWNoZWQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHVzZWQgdG8gcmVzZXQgdGhlIG9wdGlvbnMgc3RhdGUuXG4gICAgICovXG4gICAgcHJpdmF0ZSByZXNldE9wdGlvbnMoKTogdm9pZCB7XG4gICAgICAgIC8vIENyZWF0ZSBvYnNlcnZhYmxlIHRoYXQgZmlyZXMgd2hlbiB0aGUgb3B0aW9ucyBjaGFuZ2Ugb3IgdGhlIGNvbXBvbmVudCBpcyBkZXN0cm95ZWQuXG4gICAgICAgIGNvbnN0IGRlc3Ryb3lDdXJyZW50T2JzID0gbWVyZ2UodGhpcy5vcHRpb25zLmNoYW5nZXMsIHRoaXMuZGVzdHJveSQpO1xuXG4gICAgICAgIC8vIFN1YnNjcmliZSB0byBvYnNlcnZhYmxlIGRlZmluZWQgaW4gY29tcG9uZW50IHByb3BlcnRpZXMgd2hpY2ggZmlyZXMgd2hlbiBhbiBvcHRpb24gaXMgY2xpY2tlZC5cbiAgICAgICAgLy8gRGVzdHJveSBpZiB0aGUgb2JzZXJ2YWJsZSBkZWZpbmVkIGFib3ZlIHRyaWdnZXJzLlxuICAgICAgICB0aGlzLm9wdGlvbnNTdGF0dXNDaGFuZ2VzLnBpcGUodGFrZVVudGlsKGRlc3Ryb3lDdXJyZW50T2JzKSkuc3Vic2NyaWJlKChpbnN0YW5jZTogT3B0aW9uQ29tcG9uZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdE9wdGlvbihpbnN0YW5jZSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKiBTZWxlY3Rpb24gaW5pdGlhbGl6YXRpb24gd2hlbiBhIGNoYW5nZSBvY2N1cnMgaW4gb3B0aW9ucy4gKi9cbiAgICBwcml2YXRlIGluaXRTZWxlY3Rpb24oKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RWYWx1ZSh0aGlzLnZhbHVlLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB0aGF0IHRlc3RzIHdoZXRoZXIgdGhlIHRlc3RlZCBvcHRpb24gaXMgY3VycmVudGx5IHNlbGVjdGVkLlxuICAgICAqIEBwYXJhbSBvcHRpb24gT3B0aW9uIHRvIHRlc3QgYWdhaW5zdCB0aGUgc2VsZWN0ZWQgb3B0aW9uLlxuICAgICAqL1xuICAgIHByaXZhdGUgaXNPcHRpb25BY3RpdmUob3B0aW9uOiBPcHRpb25Db21wb25lbnQpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbiAmJiB0aGlzLnNlbGVjdGVkICYmIG9wdGlvbiA9PT0gdGhpcy5zZWxlY3RlZDtcbiAgICB9XG5cbiAgICAvKiogTWV0aG9kIHRoYXQgZm9jdXNlcyB0aGUgbmV4dCBvcHRpb24gaW4gdGhlIGxpc3QsIG9yIHRoZSBmaXJzdCBvbmUgaWYgdGhlIGxhc3Qgb25lIGlzIGN1cnJlbnRseSBmb2N1c2VkLiAqL1xuICAgIHByaXZhdGUgaW5jcmVtZW50Rm9jdXNlZCgpOiB2b2lkIHtcblxuICAgICAgICAvLyBHZXQgYWN0aXZlIGZvY3VzZWQgZWxlbWVudFxuICAgICAgICBjb25zdCBhY3RpdmVFbGVtZW50ID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcblxuICAgICAgICAvLyBHZXQgY29ycmVzcG9uZGluZyBvcHRpb24gZWxlbWVudCB0byB0aGUgYWJvdmVcbiAgICAgICAgY29uc3QgY29ycmVzcG9uZGluZ09wdGlvbiA9IHRoaXMub3B0aW9ucy5maW5kKG9wdGlvbiA9PiB7XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9uLmdldEh0bWxFbGVtZW50KCkgPT09IGFjdGl2ZUVsZW1lbnQ7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChjb3JyZXNwb25kaW5nT3B0aW9uKSB7XG4gICAgICAgICAgICBjb25zdCBhcnJheU9wdGlvbnMgPSB0aGlzLm9wdGlvbnMudG9BcnJheSgpO1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBhcnJheU9wdGlvbnMuaW5kZXhPZihjb3JyZXNwb25kaW5nT3B0aW9uKTtcblxuICAgICAgICAgICAgLy8gSWYgYWN0aXZlIG9wdGlvbiBpcyB0aGUgbGFzdCBvcHRpb24sIGZvY3VzIHRoZSBmaXJzdCBvbmVcbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgZm9jdXMgdGhlIG5leHQgb3B0aW9uLlxuICAgICAgICAgICAgaWYgKGluZGV4ID09PSB0aGlzLm9wdGlvbnMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIGFycmF5T3B0aW9uc1swXS5mb2N1cygpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhcnJheU9wdGlvbnNbaW5kZXggKyAxXS5mb2N1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmZpcnN0LmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogTWV0aG9kIHRoYXQgZm9jdXNlcyB0aGUgcHJldmlvdXMgb3B0aW9uIGluIHRoZSBsaXN0LCBvciB0aGUgbGFzdCBvbmUgaWYgdGhlIGxhc3Qgb25lIGlzIGN1cnJlbnRseSBmb2N1c2VkLiAqL1xuICAgIHByaXZhdGUgZGVjcmVtZW50Rm9jdXNlZCgpOiB2b2lkIHtcblxuICAgICAgICAvLyBHZXQgYWN0aXZlIGZvY3VzZWQgZWxlbWVudFxuICAgICAgICBjb25zdCBhY3RpdmVFbGVtZW50ID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcblxuICAgICAgICAvLyBHZXQgY29ycmVzcG9uZGluZyBvcHRpb24gZWxlbWVudCB0byB0aGUgYWJvdmVcbiAgICAgICAgY29uc3QgY29ycmVzcG9uZGluZ09wdGlvbiA9IHRoaXMub3B0aW9ucy5maW5kKG9wdGlvbiA9PiB7XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9uLmdldEh0bWxFbGVtZW50KCkgPT09IGFjdGl2ZUVsZW1lbnQ7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIElmIGFjdGl2ZSBvcHRpb24gaXMgdGhlIGZpcnN0IG9wdGlvbiwgZm9jdXMgdGhlIGxhc3Qgb25lXG4gICAgICAgIC8vIE90aGVyd2lzZSwgZm9jdXMgdGhlIHByZXZpb3VzIG9wdGlvbi5cbiAgICAgICAgaWYgKGNvcnJlc3BvbmRpbmdPcHRpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IGFycmF5T3B0aW9ucyA9IHRoaXMub3B0aW9ucy50b0FycmF5KCk7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IGFycmF5T3B0aW9ucy5pbmRleE9mKGNvcnJlc3BvbmRpbmdPcHRpb24pO1xuXG4gICAgICAgICAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgICAgICAgICBhcnJheU9wdGlvbnNbdGhpcy5vcHRpb25zLmxlbmd0aCAtIDFdLmZvY3VzKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFycmF5T3B0aW9uc1tpbmRleCAtIDFdLmZvY3VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuZmlyc3QuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIGhhbmRsZSBjYXNlcyB3aGVyZSBhIHVzZXIgcmVtb3ZlcyB0aGUgY3VycmVudGx5IGFjdGl2ZSBvcHRpb24uXG4gICAgICogVGhlIHRpbWVvdXQgaXMgcmVxdWlyZWQgYmVjYXVzZSB0aGlzIGNhbiBoYXBwZW4gYWZ0ZXIgdGhlIHZpZXcgaGFzIGJlZW4gY2hlY2tlZC5cbiAgICAgKi9cbiAgICBwcml2YXRlIHVuc2VsZWN0T3B0aW9ucygpOiB2b2lkIHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5zZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWQuc2V0U2VsZWN0ZWQoZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy52YWx1ZUNoYW5nZS5lbWl0KHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB0aGlzLm9uQ2hhbmdlKHVuZGVmaW5lZCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxufVxuIl19