/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Component, ContentChildren, EventEmitter, forwardRef, HostBinding, HostListener, Input, Output, QueryList, TemplateRef, ViewEncapsulation } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { OptionComponent } from './option/option.component';
import { defer, merge, Subject } from 'rxjs';
import { startWith, switchMap, takeUntil } from 'rxjs/operators';
/**
 * Select component intended to mimic the behaviour of the native select element.
 */
var SelectComponent = /** @class */ (function () {
    function SelectComponent() {
        var _this = this;
        /**
         * @hidden
         */
        this.fdDropdownClass = true;
        /**
         * Whether the select component is disabled.
         */
        this.disabled = false;
        /**
         * Open state of the select.
         */
        this.isOpen = false;
        /**
         * Whether the select is in compact mode.
         */
        this.compact = false;
        /**
         * Popper.js options of the popover.
         */
        this.popperOptions = {
            placement: 'bottom-start',
            modifiers: {
                preventOverflow: {
                    enabled: true,
                    escapeWithReference: true,
                    boundariesElement: 'scrollParent'
                }
            }
        };
        /**
         * Preset options for the popover body width.
         * * `at-least` will apply a minimum width to the body equivalent to the width of the control.
         * * `equal` will apply a width to the body equivalent to the width of the control.
         * * Leave blank for no effect.
         */
        this.fillControlMode = 'at-least';
        /**
         * Event emitted when the popover open state changes.
         */
        this.isOpenChange = new EventEmitter();
        /**
         * Event emitted when the selected value of the select changes.
         */
        this.valueChange = new EventEmitter();
        /**
         * Subject triggered when the component is destroyed.
         */
        this.destroy$ = new Subject();
        /**
         * Observable triggered when an option has its selectedChange event fire.
         */
        this.optionsStatusChanges = (/** @type {?} */ (defer((/**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var options = _this.options;
            if (options) {
                return options.changes.pipe(startWith(options), switchMap((/**
                 * @return {?}
                 */
                function () { return merge.apply(void 0, tslib_1.__spread(options.map((/**
                 * @param {?} option
                 * @return {?}
                 */
                function (option) { return option.selectedChange; })))); })));
            }
        }))));
        /**
         * @hidden
         */
        this.onChange = (/**
         * @return {?}
         */
        function () { });
        /**
         * @hidden
         */
        this.onTouched = (/**
         * @return {?}
         */
        function () { });
    }
    /** @hidden */
    /**
     * @hidden
     * @param {?} changes
     * @return {?}
     */
    SelectComponent.prototype.ngOnChanges = /**
     * @hidden
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        var _this = this;
        if (changes.value) {
            setTimeout((/**
             * @return {?}
             */
            function () {
                if (_this.value) {
                    _this.selectValue(_this.value, false);
                }
            }));
        }
    };
    /** @hidden */
    /**
     * @hidden
     * @return {?}
     */
    SelectComponent.prototype.ngAfterContentInit = /**
     * @hidden
     * @return {?}
     */
    function () {
        var _this = this;
        // If the observable state changes, reset the options and initialize selection.
        this.options.changes.pipe(startWith(null), takeUntil(this.destroy$)).subscribe((/**
         * @return {?}
         */
        function () {
            _this.resetOptions();
            _this.initSelection();
        }));
    };
    /** @hidden */
    /**
     * @hidden
     * @return {?}
     */
    SelectComponent.prototype.ngOnDestroy = /**
     * @hidden
     * @return {?}
     */
    function () {
        this.destroy$.next();
        this.destroy$.complete();
    };
    /** Toggles the open state of the select. */
    /**
     * Toggles the open state of the select.
     * @return {?}
     */
    SelectComponent.prototype.toggle = /**
     * Toggles the open state of the select.
     * @return {?}
     */
    function () {
        if (this.isOpen && !this.disabled) {
            this.close();
        }
        else {
            this.open();
        }
    };
    /** Opens the select popover body. */
    /**
     * Opens the select popover body.
     * @return {?}
     */
    SelectComponent.prototype.open = /**
     * Opens the select popover body.
     * @return {?}
     */
    function () {
        if (!this.isOpen && !this.disabled) {
            this.isOpen = true;
            this.isOpenChange.emit(this.isOpen);
        }
    };
    /** Closes the select popover body. */
    /**
     * Closes the select popover body.
     * @return {?}
     */
    SelectComponent.prototype.close = /**
     * Closes the select popover body.
     * @return {?}
     */
    function () {
        if (this.isOpen && !this.disabled) {
            this.isOpen = false;
            this.isOpenChange.emit(this.isOpen);
        }
    };
    /** @hidden */
    /**
     * @hidden
     * @param {?} fn
     * @return {?}
     */
    SelectComponent.prototype.registerOnChange = /**
     * @hidden
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this.onChange = fn;
    };
    /** @hidden */
    /**
     * @hidden
     * @param {?} fn
     * @return {?}
     */
    SelectComponent.prototype.registerOnTouched = /**
     * @hidden
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this.onTouched = fn;
    };
    /** @hidden */
    /**
     * @hidden
     * @param {?} isDisabled
     * @return {?}
     */
    SelectComponent.prototype.setDisabledState = /**
     * @hidden
     * @param {?} isDisabled
     * @return {?}
     */
    function (isDisabled) {
        this.disabled = isDisabled;
    };
    /** @hidden */
    /**
     * @hidden
     * @param {?} value
     * @return {?}
     */
    SelectComponent.prototype.writeValue = /**
     * @hidden
     * @param {?} value
     * @return {?}
     */
    function (value) {
        var _this = this;
        if (this.options) {
            this.selectValue(value, false);
        }
        else {
            // Defer the selection of the value to support forms
            Promise.resolve().then((/**
             * @return {?}
             */
            function () {
                if (_this.options) {
                    _this.selectValue(value, false);
                }
            }));
        }
    };
    Object.defineProperty(SelectComponent.prototype, "triggerValue", {
        /** Returns the current trigger value if there is a selected option. Otherwise, returns the placeholder. */
        get: /**
         * Returns the current trigger value if there is a selected option. Otherwise, returns the placeholder.
         * @return {?}
         */
        function () {
            return this.selected ? this.selected.viewValueText : this.placeholder;
        },
        enumerable: true,
        configurable: true
    });
    /** @hidden */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    SelectComponent.prototype.keydownHandler = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        switch (event.code) {
            case ('ArrowUp'): {
                event.preventDefault();
                this.decrementFocused();
                break;
            }
            case ('ArrowDown'): {
                event.preventDefault();
                this.incrementFocused();
                break;
            }
        }
    };
    /**
     * Selects an option by option component reference. Preferred method of selection.
     * @param option The option component to search for.
     * @param fireEvents Whether to fire change events.
     */
    /**
     * Selects an option by option component reference. Preferred method of selection.
     * @private
     * @param {?} option The option component to search for.
     * @param {?=} fireEvents Whether to fire change events.
     * @return {?}
     */
    SelectComponent.prototype.selectOption = /**
     * Selects an option by option component reference. Preferred method of selection.
     * @private
     * @param {?} option The option component to search for.
     * @param {?=} fireEvents Whether to fire change events.
     * @return {?}
     */
    function (option, fireEvents) {
        if (fireEvents === void 0) { fireEvents = true; }
        if (!this.isOptionActive(option)) {
            if (this.selected) {
                this.selected.setSelected(false, false);
            }
            option.setSelected(true, false);
            this.selected = option;
            this.updateValue(fireEvents);
            this.close();
            return option;
        }
        return;
    };
    /**
     * Selects an option by value. If two components have the same value, the first one found is selected.
     * Recommend using selectOption generally.
     * @param value Value to search for.
     * @param fireEvents Whether to fire change events.
     */
    /**
     * Selects an option by value. If two components have the same value, the first one found is selected.
     * Recommend using selectOption generally.
     * @private
     * @param {?} value Value to search for.
     * @param {?=} fireEvents Whether to fire change events.
     * @return {?}
     */
    SelectComponent.prototype.selectValue = /**
     * Selects an option by value. If two components have the same value, the first one found is selected.
     * Recommend using selectOption generally.
     * @private
     * @param {?} value Value to search for.
     * @param {?=} fireEvents Whether to fire change events.
     * @return {?}
     */
    function (value, fireEvents) {
        if (fireEvents === void 0) { fireEvents = true; }
        /** @type {?} */
        var matchOption = this.options.find((/**
         * @param {?} option
         * @return {?}
         */
        function (option) {
            return option.value != null && option.value === value;
        }));
        // If not match is found, set everything to null
        // This is mostly only for cases where a user removes an active option
        if (!matchOption) {
            this.unselectOptions();
            return;
        }
        // If match is found, select the new value
        if (matchOption && !this.isOptionActive(matchOption)) {
            if (this.selected) {
                this.selected.setSelected(false, false);
            }
            matchOption.setSelected(true, false);
            this.selected = matchOption;
            this.updateValue(fireEvents);
            this.close();
        }
        return matchOption;
    };
    /**
     * Updates the value parameter with optional events.
     * @param fireEvents If true, function fires valueChange, onChange and onTouched events.
     */
    /**
     * Updates the value parameter with optional events.
     * @private
     * @param {?=} fireEvents If true, function fires valueChange, onChange and onTouched events.
     * @return {?}
     */
    SelectComponent.prototype.updateValue = /**
     * Updates the value parameter with optional events.
     * @private
     * @param {?=} fireEvents If true, function fires valueChange, onChange and onTouched events.
     * @return {?}
     */
    function (fireEvents) {
        if (fireEvents === void 0) { fireEvents = true; }
        this.value = this.selected.value;
        if (fireEvents) {
            this.valueChange.emit(this.value);
            this.onChange(this.value);
            this.onTouched();
        }
    };
    /**
     * Function used to reset the options state.
     */
    /**
     * Function used to reset the options state.
     * @private
     * @return {?}
     */
    SelectComponent.prototype.resetOptions = /**
     * Function used to reset the options state.
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        // Create observable that fires when the options change or the component is destroyed.
        /** @type {?} */
        var destroyCurrentObs = merge(this.options.changes, this.destroy$);
        // Subscribe to observable defined in component properties which fires when an option is clicked.
        // Destroy if the observable defined above triggers.
        this.optionsStatusChanges.pipe(takeUntil(destroyCurrentObs)).subscribe((/**
         * @param {?} instance
         * @return {?}
         */
        function (instance) {
            _this.selectOption(instance);
        }));
    };
    /** Selection initialization when a change occurs in options. */
    /**
     * Selection initialization when a change occurs in options.
     * @private
     * @return {?}
     */
    SelectComponent.prototype.initSelection = /**
     * Selection initialization when a change occurs in options.
     * @private
     * @return {?}
     */
    function () {
        if (this.value) {
            this.selected = undefined;
            this.selectValue(this.value, false);
        }
    };
    /**
     * Function that tests whether the tested option is currently selected.
     * @param option Option to test against the selected option.
     */
    /**
     * Function that tests whether the tested option is currently selected.
     * @private
     * @param {?} option Option to test against the selected option.
     * @return {?}
     */
    SelectComponent.prototype.isOptionActive = /**
     * Function that tests whether the tested option is currently selected.
     * @private
     * @param {?} option Option to test against the selected option.
     * @return {?}
     */
    function (option) {
        return option && this.selected && option === this.selected;
    };
    /** Method that focuses the next option in the list, or the first one if the last one is currently focused. */
    /**
     * Method that focuses the next option in the list, or the first one if the last one is currently focused.
     * @private
     * @return {?}
     */
    SelectComponent.prototype.incrementFocused = /**
     * Method that focuses the next option in the list, or the first one if the last one is currently focused.
     * @private
     * @return {?}
     */
    function () {
        // Get active focused element
        /** @type {?} */
        var activeElement = document.activeElement;
        // Get corresponding option element to the above
        /** @type {?} */
        var correspondingOption = this.options.find((/**
         * @param {?} option
         * @return {?}
         */
        function (option) {
            return option.getHtmlElement() === activeElement;
        }));
        if (correspondingOption) {
            /** @type {?} */
            var arrayOptions = this.options.toArray();
            /** @type {?} */
            var index = arrayOptions.indexOf(correspondingOption);
            // If active option is the last option, focus the first one
            // Otherwise, focus the next option.
            if (index === this.options.length - 1) {
                arrayOptions[0].focus();
            }
            else {
                arrayOptions[index + 1].focus();
            }
        }
        else if (this.options) {
            this.options.first.focus();
        }
    };
    /** Method that focuses the previous option in the list, or the last one if the last one is currently focused. */
    /**
     * Method that focuses the previous option in the list, or the last one if the last one is currently focused.
     * @private
     * @return {?}
     */
    SelectComponent.prototype.decrementFocused = /**
     * Method that focuses the previous option in the list, or the last one if the last one is currently focused.
     * @private
     * @return {?}
     */
    function () {
        // Get active focused element
        /** @type {?} */
        var activeElement = document.activeElement;
        // Get corresponding option element to the above
        /** @type {?} */
        var correspondingOption = this.options.find((/**
         * @param {?} option
         * @return {?}
         */
        function (option) {
            return option.getHtmlElement() === activeElement;
        }));
        // If active option is the first option, focus the last one
        // Otherwise, focus the previous option.
        if (correspondingOption) {
            /** @type {?} */
            var arrayOptions = this.options.toArray();
            /** @type {?} */
            var index = arrayOptions.indexOf(correspondingOption);
            if (index === 0) {
                arrayOptions[this.options.length - 1].focus();
            }
            else {
                arrayOptions[index - 1].focus();
            }
        }
        else if (this.options) {
            this.options.first.focus();
        }
    };
    /**
     * Method used to handle cases where a user removes the currently active option.
     * The timeout is required because this can happen after the view has been checked.
     */
    /**
     * Method used to handle cases where a user removes the currently active option.
     * The timeout is required because this can happen after the view has been checked.
     * @private
     * @return {?}
     */
    SelectComponent.prototype.unselectOptions = /**
     * Method used to handle cases where a user removes the currently active option.
     * The timeout is required because this can happen after the view has been checked.
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        setTimeout((/**
         * @return {?}
         */
        function () {
            if (_this.selected) {
                _this.selected.setSelected(false, false);
            }
            _this.selected = undefined;
            _this.value = undefined;
            _this.valueChange.emit(undefined);
            _this.onChange(undefined);
        }));
    };
    SelectComponent.decorators = [
        { type: Component, args: [{
                    selector: 'fd-select',
                    template: "<fd-popover [(isOpen)]=\"isOpen\"\n            (isOpenChange)=\"isOpenChange.emit($event)\"\n            [options]=\"popperOptions\"\n            [fillControlMode]=\"fillControlMode\"\n            [appendTo]=\"appendTo\"\n            class=\"fd-select-popover-custom\">\n    <fd-popover-control>\n        <ng-container *ngIf=\"triggerTemplate\">\n            <ng-container *ngTemplateOutlet=\"triggerTemplate; context: {$implicit: this}\"></ng-container>\n        </ng-container>\n        <ng-container *ngIf=\"!triggerTemplate\">\n            <button class=\"fd-dropdown__control fd-button fd-select-button-custom\"\n                    aria-haspopup=\"true\"\n                    [ngClass]=\"{'fd-button--compact': compact}\"\n                    [attr.aria-expanded]=\"isOpen\"\n                    [disabled]=\"disabled\">\n                <span class=\"fd-select-text-custom\">{{triggerValue}}</span>\n            </button>\n        </ng-container>\n    </fd-popover-control>\n    <fd-popover-body>\n        <ng-content></ng-content>\n    </fd-popover-body>\n</fd-popover>\n",
                    encapsulation: ViewEncapsulation.None,
                    providers: [
                        {
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: forwardRef((/**
                             * @return {?}
                             */
                            function () { return SelectComponent; })),
                            multi: true
                        }
                    ],
                    host: {
                        '[class.fd-select-custom]': 'true',
                        'role': 'listbox',
                    },
                    styles: [".fd-select-custom{display:inline-block;width:100%}.fd-select-custom .fd-select-popover-custom{display:block}.fd-select-custom .fd-select-popover-custom fd-popover-container{min-width:100%;overflow:auto}.fd-select-custom .fd-select-button-custom{display:flex;align-items:flex-end;justify-content:space-between}.fd-select-custom .fd-select-button-custom::after{flex-shrink:0;margin-top:0}.fd-select-custom .fd-select-text-custom{text-overflow:ellipsis;white-space:nowrap;overflow-x:hidden}"]
                }] }
    ];
    SelectComponent.propDecorators = {
        fdDropdownClass: [{ type: HostBinding, args: ['class.fd-dropdown',] }],
        options: [{ type: ContentChildren, args: [OptionComponent, { descendants: true },] }],
        disabled: [{ type: Input }],
        placeholder: [{ type: Input }],
        isOpen: [{ type: Input }],
        value: [{ type: Input }],
        compact: [{ type: Input }],
        popperOptions: [{ type: Input }],
        fillControlMode: [{ type: Input }],
        triggerTemplate: [{ type: Input }],
        appendTo: [{ type: Input }],
        isOpenChange: [{ type: Output }],
        valueChange: [{ type: Output }],
        keydownHandler: [{ type: HostListener, args: ['keydown', ['$event'],] }]
    };
    return SelectComponent;
}());
export { SelectComponent };
if (false) {
    /**
     * @hidden
     * @type {?}
     */
    SelectComponent.prototype.fdDropdownClass;
    /**
     * @hidden
     * @type {?}
     */
    SelectComponent.prototype.options;
    /**
     * Whether the select component is disabled.
     * @type {?}
     */
    SelectComponent.prototype.disabled;
    /**
     * Placeholder for the select. Appears in the triggerbox if no option is selected.
     * @type {?}
     */
    SelectComponent.prototype.placeholder;
    /**
     * Open state of the select.
     * @type {?}
     */
    SelectComponent.prototype.isOpen;
    /**
     * Current value of the selected option.
     * @type {?}
     */
    SelectComponent.prototype.value;
    /**
     * Whether the select is in compact mode.
     * @type {?}
     */
    SelectComponent.prototype.compact;
    /**
     * Popper.js options of the popover.
     * @type {?}
     */
    SelectComponent.prototype.popperOptions;
    /**
     * Preset options for the popover body width.
     * * `at-least` will apply a minimum width to the body equivalent to the width of the control.
     * * `equal` will apply a width to the body equivalent to the width of the control.
     * * Leave blank for no effect.
     * @type {?}
     */
    SelectComponent.prototype.fillControlMode;
    /**
     * Template with which to display the trigger box.
     * @type {?}
     */
    SelectComponent.prototype.triggerTemplate;
    /**
     * The element to which the popover should be appended.
     * @type {?}
     */
    SelectComponent.prototype.appendTo;
    /**
     * Event emitted when the popover open state changes.
     * @type {?}
     */
    SelectComponent.prototype.isOpenChange;
    /**
     * Event emitted when the selected value of the select changes.
     * @type {?}
     */
    SelectComponent.prototype.valueChange;
    /**
     * Current selected option component reference.
     * @type {?}
     * @private
     */
    SelectComponent.prototype.selected;
    /**
     * Subject triggered when the component is destroyed.
     * @type {?}
     * @private
     */
    SelectComponent.prototype.destroy$;
    /**
     * Observable triggered when an option has its selectedChange event fire.
     * @type {?}
     * @private
     */
    SelectComponent.prototype.optionsStatusChanges;
    /**
     * @hidden
     * @type {?}
     */
    SelectComponent.prototype.onChange;
    /**
     * @hidden
     * @type {?}
     */
    SelectComponent.prototype.onTouched;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VsZWN0LmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2Z1bmRhbWVudGFsLW5neC8iLCJzb3VyY2VzIjpbImxpYi9zZWxlY3Qvc2VsZWN0LmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLE9BQU8sRUFFSCxTQUFTLEVBQ1QsZUFBZSxFQUNmLFlBQVksRUFBRSxVQUFVLEVBQUUsV0FBVyxFQUFFLFlBQVksRUFDbkQsS0FBSyxFQUNMLE1BQU0sRUFDTixTQUFTLEVBQWlCLFdBQVcsRUFDckMsaUJBQWlCLEVBQ3BCLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBd0IsaUJBQWlCLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUN6RSxPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sMkJBQTJCLENBQUM7QUFDNUQsT0FBTyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQWMsT0FBTyxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQ3pELE9BQU8sRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxNQUFNLGdCQUFnQixDQUFDOzs7O0FBT2pFO0lBQUE7UUFBQSxpQkEwWEM7Ozs7UUFyV0csb0JBQWUsR0FBWSxJQUFJLENBQUM7Ozs7UUFRaEMsYUFBUSxHQUFZLEtBQUssQ0FBQzs7OztRQVExQixXQUFNLEdBQVksS0FBSyxDQUFDOzs7O1FBUXhCLFlBQU8sR0FBWSxLQUFLLENBQUM7Ozs7UUFJekIsa0JBQWEsR0FBa0I7WUFDM0IsU0FBUyxFQUFFLGNBQWM7WUFDekIsU0FBUyxFQUFFO2dCQUNQLGVBQWUsRUFBRTtvQkFDYixPQUFPLEVBQUUsSUFBSTtvQkFDYixtQkFBbUIsRUFBRSxJQUFJO29CQUN6QixpQkFBaUIsRUFBRSxjQUFjO2lCQUNwQzthQUNKO1NBQ0osQ0FBQzs7Ozs7OztRQVNGLG9CQUFlLEdBQW9CLFVBQVUsQ0FBQzs7OztRQVlyQyxpQkFBWSxHQUNmLElBQUksWUFBWSxFQUFXLENBQUM7Ozs7UUFJekIs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Q0FDVzs7Ozs7SUFHWCxrQ0FDeUI7Ozs7O0lBR3pCLHdDQVVFOzs7Ozs7OztJQVFGLDBDQUM4Qzs7Ozs7SUFHOUMsMENBQ2tDOzs7OztJQUdsQyxtQ0FDK0I7Ozs7O0lBRy9CLHVDQUVrQzs7Ozs7SUFHbEMsc0NBRThCOzs7Ozs7SUFHOUIsbUNBQWtDOzs7Ozs7SUFHbEMsbUNBQStEOzs7Ozs7SUFHL0QsK0NBUWtDOzs7OztJQUdsQyxtQ0FBOEI7Ozs7O0lBRzlCLG9DQUErQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gICAgQWZ0ZXJDb250ZW50SW5pdCxcbiAgICBDb21wb25lbnQsXG4gICAgQ29udGVudENoaWxkcmVuLFxuICAgIEV2ZW50RW1pdHRlciwgZm9yd2FyZFJlZiwgSG9zdEJpbmRpbmcsIEhvc3RMaXN0ZW5lcixcbiAgICBJbnB1dCwgT25DaGFuZ2VzLCBPbkRlc3Ryb3ksXG4gICAgT3V0cHV0LFxuICAgIFF1ZXJ5TGlzdCwgU2ltcGxlQ2hhbmdlcywgVGVtcGxhdGVSZWYsXG4gICAgVmlld0VuY2Fwc3VsYXRpb25cbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb250cm9sVmFsdWVBY2Nlc3NvciwgTkdfVkFMVUVfQUNDRVNTT1IgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBPcHRpb25Db21wb25lbnQgfSBmcm9tICcuL29wdGlvbi9vcHRpb24uY29tcG9uZW50JztcbmltcG9ydCB7IGRlZmVyLCBtZXJnZSwgT2JzZXJ2YWJsZSwgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgc3RhcnRXaXRoLCBzd2l0Y2hNYXAsIHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IFBvcHBlck9wdGlvbnMgfSBmcm9tICdwb3BwZXIuanMnO1xuaW1wb3J0IHsgUG9wb3ZlckZpbGxNb2RlIH0gZnJvbSAnLi4vcG9wb3Zlci9wb3BvdmVyLWRpcmVjdGl2ZS9wb3BvdmVyLmRpcmVjdGl2ZSc7XG5cbi8qKlxuICogU2VsZWN0IGNvbXBvbmVudCBpbnRlbmRlZCB0byBtaW1pYyB0aGUgYmVoYXZpb3VyIG9mIHRoZSBuYXRpdmUgc2VsZWN0IGVsZW1lbnQuXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnZmQtc2VsZWN0JyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vc2VsZWN0LmNvbXBvbmVudC5odG1sJyxcbiAgICBzdHlsZVVybHM6IFsnLi9zZWxlY3QuY29tcG9uZW50LnNjc3MnXSxcbiAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgIHByb3ZpZGVyczogW1xuICAgICAgICB7XG4gICAgICAgICAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICAgICAgICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IFNlbGVjdENvbXBvbmVudCksXG4gICAgICAgICAgICBtdWx0aTogdHJ1ZVxuICAgICAgICB9XG4gICAgXSxcbiAgICBob3N0OiB7XG4gICAgICAgICdbY2xhc3MuZmQtc2VsZWN0LWN1c3RvbV0nOiAndHJ1ZScsXG4gICAgICAgICdyb2xlJzogJ2xpc3Rib3gnLFxuICAgIH1cbn0pXG5leHBvcnQgY2xhc3MgU2VsZWN0Q29tcG9uZW50IGltcGxlbWVudHMgT25DaGFuZ2VzLCBBZnRlckNvbnRlbnRJbml0LCBPbkRlc3Ryb3ksIENvbnRyb2xWYWx1ZUFjY2Vzc29yIHtcblxuICAgIC8qKiBAaGlkZGVuICovXG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcy5mZC1kcm9wZG93bicpXG4gICAgZmREcm9wZG93bkNsYXNzOiBib29sZWFuID0gdHJ1ZTtcblxuICAgIC8qKiBAaGlkZGVuICovXG4gICAgQENvbnRlbnRDaGlsZHJlbihPcHRpb25Db21wb25lbnQsIHsgZGVzY2VuZGFudHM6IHRydWUgfSlcbiAgICBvcHRpb25zOiBRdWVyeUxpc3Q8T3B0aW9uQ29tcG9uZW50PjtcblxuICAgIC8qKiBXaGV0aGVyIHRoZSBzZWxlY3QgY29tcG9uZW50IGlzIGRpc2FibGVkLiAqL1xuICAgIEBJbnB1dCgpXG4gICAgZGlzYWJsZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKiBQbGFjZWhvbGRlciBmb3IgdGhlIHNlbGVjdC4gQXBwZWFycyBpbiB0aGUgdHJpZ2dlcmJveCBpZiBubyBvcHRpb24gaXMgc2VsZWN0ZWQuICovXG4gICAgQElucHV0KClcbiAgICBwbGFjZWhvbGRlcjogc3RyaW5nO1xuXG4gICAgLyoqIE9wZW4gc3RhdGUgb2YgdGhlIHNlbGVjdC4gKi9cbiAgICBASW5wdXQoKVxuICAgIGlzT3BlbjogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgLyoqIEN1cnJlbnQgdmFsdWUgb2YgdGhlIHNlbGVjdGVkIG9wdGlvbi4gKi9cbiAgICBASW5wdXQoKVxuICAgIHZhbHVlOiBhbnk7XG5cbiAgICAvKiogV2hldGhlciB0aGUgc2VsZWN0IGlzIGluIGNvbXBhY3QgbW9kZS4gKi9cbiAgICBASW5wdXQoKVxuICAgIGNvbXBhY3Q6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKiBQb3BwZXIuanMgb3B0aW9ucyBvZiB0aGUgcG9wb3Zlci4gKi9cbiAgICBASW5wdXQoKVxuICAgIHBvcHBlck9wdGlvbnM6IFBvcHBlck9wdGlvbnMgPSB7XG4gICAgICAgIHBsYWNlbWVudDogJ2JvdHRvbS1zdGFydCcsXG4gICAgICAgIG1vZGlmaWVyczoge1xuICAgICAgICAgICAgcHJldmVudE92ZXJmbG93OiB7XG4gICAgICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBlc2NhcGVXaXRoUmVmZXJlbmNlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGJvdW5kYXJpZXNFbGVtZW50OiAnc2Nyb2xsUGFyZW50J1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFByZXNldCBvcHRpb25zIGZvciB0aGUgcG9wb3ZlciBib2R5IHdpZHRoLlxuICAgICAqICogYGF0LWxlYXN0YCB3aWxsIGFwcGx5IGEgbWluaW11bSB3aWR0aCB0byB0aGUgYm9keSBlcXVpdmFsZW50IHRvIHRoZSB3aWR0aCBvZiB0aGUgY29udHJvbC5cbiAgICAgKiAqIGBlcXVhbGAgd2lsbCBhcHBseSBhIHdpZHRoIHRvIHRoZSBib2R5IGVxdWl2YWxlbnQgdG8gdGhlIHdpZHRoIG9mIHRoZSBjb250cm9sLlxuICAgICAqICogTGVhdmUgYmxhbmsgZm9yIG5vIGVmZmVjdC5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGZpbGxDb250cm9sTW9kZTogUG9wb3ZlckZpbGxNb2RlID0gJ2F0LWxlYXN0JztcblxuICAgIC8qKiBUZW1wbGF0ZSB3aXRoIHdoaWNoIHRvIGRpc3BsYXkgdGhlIHRyaWdnZXIgYm94LiAqL1xuICAgIEBJbnB1dCgpXG4gICAgdHJpZ2dlclRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG4gICAgLyoqIFRoZSBlbGVtZW50IHRvIHdoaWNoIHRoZSBwb3BvdmVyIHNob3VsZCBiZSBhcHBlbmRlZC4gKi9cbiAgICBASW5wdXQoKVxuICAgIGFwcGVuZFRvOiBIVE1MRWxlbWVudCB8ICdib2R5JztcblxuICAgIC8qKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIHBvcG92ZXIgb3BlbiBzdGF0ZSBjaGFuZ2VzLiAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHJlYWRvbmx5IGlzT3BlbkNoYW5nZTogRXZlbnRFbWl0dGVyPGJvb2xlYW4+XG4gICAgICAgID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPigpO1xuXG4gICAgLyoqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgc2VsZWN0ZWQgdmFsdWUgb2YgdGhlIHNlbGVjdCBjaGFuZ2VzLiAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHJlYWRvbmx5IHZhbHVlQ2hhbmdlOiBFdmVudEVtaXR0ZXI8YW55PlxuICAgICAgICA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuXG4gICAgLyoqIEN1cnJlbnQgc2VsZWN0ZWQgb3B0aW9uIGNvbXBvbmVudCByZWZlcmVuY2UuICovXG4gICAgcHJpdmF0ZSBzZWxlY3RlZDogT3B0aW9uQ29tcG9uZW50O1xuXG4gICAgLyoqIFN1YmplY3QgdHJpZ2dlcmVkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBkZXN0cm95ZWQuICovXG4gICAgcHJpdmF0ZSByZWFkb25seSBkZXN0cm95JDogU3ViamVjdDx2b2lkPiA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG5cbiAgICAvKiogT2JzZXJ2YWJsZSB0cmlnZ2VyZWQgd2hlbiBhbiBvcHRpb24gaGFzIGl0cyBzZWxlY3RlZENoYW5nZSBldmVudCBmaXJlLiAqL1xuICAgIHByaXZhdGUgcmVhZG9ubHkgb3B0aW9uc1N0YXR1c0NoYW5nZXM6IE9ic2VydmFibGU8T3B0aW9uQ29tcG9uZW50PiA9IGRlZmVyKCgpID0+IHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmNoYW5nZXMucGlwZShcbiAgICAgICAgICAgICAgICBzdGFydFdpdGgob3B0aW9ucyksXG4gICAgICAgICAgICAgICAgc3dpdGNoTWFwKCgpID0+IG1lcmdlKC4uLm9wdGlvbnMubWFwKG9wdGlvbiA9PiBvcHRpb24uc2VsZWN0ZWRDaGFuZ2UpKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9KSBhcyBPYnNlcnZhYmxlPE9wdGlvbkNvbXBvbmVudD47XG5cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIG9uQ2hhbmdlOiBGdW5jdGlvbiA9ICgpID0+IHt9O1xuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBvblRvdWNoZWQ6IEZ1bmN0aW9uID0gKCkgPT4ge307XG5cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkIHtcbiAgICAgICAgaWYgKGNoYW5nZXMudmFsdWUpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0VmFsdWUodGhpcy52YWx1ZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBuZ0FmdGVyQ29udGVudEluaXQoKTogdm9pZCB7XG5cbiAgICAgICAgLy8gSWYgdGhlIG9ic2VydmFibGUgc3RhdGUgY2hhbmdlcywgcmVzZXQgdGhlIG9wdGlvbnMgYW5kIGluaXRpYWxpemUgc2VsZWN0aW9uLlxuICAgICAgICB0aGlzLm9wdGlvbnMuY2hhbmdlcy5waXBlKHN0YXJ0V2l0aChudWxsKSwgdGFrZVVudGlsKHRoaXMuZGVzdHJveSQpKS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZXNldE9wdGlvbnMoKTtcbiAgICAgICAgICAgIHRoaXMuaW5pdFNlbGVjdGlvbigpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgICAgICB0aGlzLmRlc3Ryb3kkLm5leHQoKTtcbiAgICAgICAgdGhpcy5kZXN0cm95JC5jb21wbGV0ZSgpO1xuICAgIH1cblxuICAgIC8qKiBUb2dnbGVzIHRoZSBvcGVuIHN0YXRlIG9mIHRoZSBzZWxlY3QuICovXG4gICAgdG9nZ2xlKCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5pc09wZW4gJiYgIXRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub3BlbigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIE9wZW5zIHRoZSBzZWxlY3QgcG9wb3ZlciBib2R5LiAqL1xuICAgIG9wZW4oKTogdm9pZCB7XG4gICAgICAgIGlmICghdGhpcy5pc09wZW4gJiYgIXRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaXNPcGVuID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuaXNPcGVuQ2hhbmdlLmVtaXQodGhpcy5pc09wZW4pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIENsb3NlcyB0aGUgc2VsZWN0IHBvcG92ZXIgYm9keS4gKi9cbiAgICBjbG9zZSgpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuaXNPcGVuICYmICF0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgICAgICB0aGlzLmlzT3BlbiA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5pc09wZW5DaGFuZ2UuZW1pdCh0aGlzLmlzT3Blbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIHJlZ2lzdGVyT25DaGFuZ2UoZm46IGFueSk6IHZvaWQge1xuICAgICAgICB0aGlzLm9uQ2hhbmdlID0gZm47XG4gICAgfVxuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICByZWdpc3Rlck9uVG91Y2hlZChmbjogYW55KTogdm9pZCB7XG4gICAgICAgIHRoaXMub25Ub3VjaGVkID0gZm47XG4gICAgfVxuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBzZXREaXNhYmxlZFN0YXRlKGlzRGlzYWJsZWQ6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IGlzRGlzYWJsZWQ7XG4gICAgfVxuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICB3cml0ZVZhbHVlKHZhbHVlOiBhbnkpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RWYWx1ZSh2YWx1ZSwgZmFsc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRGVmZXIgdGhlIHNlbGVjdGlvbiBvZiB0aGUgdmFsdWUgdG8gc3VwcG9ydCBmb3Jtc1xuICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdFZhbHVlKHZhbHVlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogUmV0dXJucyB0aGUgY3VycmVudCB0cmlnZ2VyIHZhbHVlIGlmIHRoZXJlIGlzIGEgc2VsZWN0ZWQgb3B0aW9uLiBPdGhlcndpc2UsIHJldHVybnMgdGhlIHBsYWNlaG9sZGVyLiAqL1xuICAgIGdldCB0cmlnZ2VyVmFsdWUoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0ZWQgPyB0aGlzLnNlbGVjdGVkLnZpZXdWYWx1ZVRleHQgOiB0aGlzLnBsYWNlaG9sZGVyO1xuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuICovXG4gICAgQEhvc3RMaXN0ZW5lcigna2V5ZG93bicsIFsnJGV2ZW50J10pXG4gICAga2V5ZG93bkhhbmRsZXIoZXZlbnQ6IEtleWJvYXJkRXZlbnQpOiB2b2lkIHtcbiAgICAgICAgc3dpdGNoIChldmVudC5jb2RlKSB7XG4gICAgICAgICAgICBjYXNlICgnQXJyb3dVcCcpOiB7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRlY3JlbWVudEZvY3VzZWQoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgKCdBcnJvd0Rvd24nKToge1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmNyZW1lbnRGb2N1c2VkKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZWxlY3RzIGFuIG9wdGlvbiBieSBvcHRpb24gY29tcG9uZW50IHJlZmVyZW5jZS4gUHJlZmVycmVkIG1ldGhvZCBvZiBzZWxlY3Rpb24uXG4gICAgICogQHBhcmFtIG9wdGlvbiBUaGUgb3B0aW9uIGNvbXBvbmVudCB0byBzZWFyY2ggZm9yLlxuICAgICAqIEBwYXJhbSBmaXJlRXZlbnRzIFdoZXRoZXIgdG8gZmlyZSBjaGFuZ2UgZXZlbnRzLlxuICAgICAqL1xuICAgIHByaXZhdGUgc2VsZWN0T3B0aW9uKG9wdGlvbjogT3B0aW9uQ29tcG9uZW50LCBmaXJlRXZlbnRzOiBib29sZWFuID0gdHJ1ZSk6IE9wdGlvbkNvbXBvbmVudCB8IHVuZGVmaW5lZCB7XG4gICAgICAgIGlmICghdGhpcy5pc09wdGlvbkFjdGl2ZShvcHRpb24pKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWQuc2V0U2VsZWN0ZWQoZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wdGlvbi5zZXRTZWxlY3RlZCh0cnVlLCBmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkID0gb3B0aW9uO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVWYWx1ZShmaXJlRXZlbnRzKTtcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgICAgIHJldHVybiBvcHRpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlbGVjdHMgYW4gb3B0aW9uIGJ5IHZhbHVlLiBJZiB0d28gY29tcG9uZW50cyBoYXZlIHRoZSBzYW1lIHZhbHVlLCB0aGUgZmlyc3Qgb25lIGZvdW5kIGlzIHNlbGVjdGVkLlxuICAgICAqIFJlY29tbWVuZCB1c2luZyBzZWxlY3RPcHRpb24gZ2VuZXJhbGx5LlxuICAgICAqIEBwYXJhbSB2YWx1ZSBWYWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgICAqIEBwYXJhbSBmaXJlRXZlbnRzIFdoZXRoZXIgdG8gZmlyZSBjaGFuZ2UgZXZlbnRzLlxuICAgICAqL1xuICAgIHByaXZhdGUgc2VsZWN0VmFsdWUodmFsdWU6IGFueSwgZmlyZUV2ZW50czogYm9vbGVhbiA9IHRydWUpOiBPcHRpb25Db21wb25lbnQgfCB1bmRlZmluZWQge1xuICAgICAgICBjb25zdCBtYXRjaE9wdGlvbiA9IHRoaXMub3B0aW9ucy5maW5kKChvcHRpb246IE9wdGlvbkNvbXBvbmVudCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbi52YWx1ZSAhPSBudWxsICYmIG9wdGlvbi52YWx1ZSA9PT0gdmFsdWU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIElmIG5vdCBtYXRjaCBpcyBmb3VuZCwgc2V0IGV2ZXJ5dGhpbmcgdG8gbnVsbFxuICAgICAgICAvLyBUaGlzIGlzIG1vc3RseSBvbmx5IGZvciBjYXNlcyB3aGVyZSBhIHVzZXIgcmVtb3ZlcyBhbiBhY3RpdmUgb3B0aW9uXG4gICAgICAgIGlmICghbWF0Y2hPcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMudW5zZWxlY3RPcHRpb25zKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBtYXRjaCBpcyBmb3VuZCwgc2VsZWN0IHRoZSBuZXcgdmFsdWVcbiAgICAgICAgaWYgKG1hdGNoT3B0aW9uICYmICF0aGlzLmlzT3B0aW9uQWN0aXZlKG1hdGNoT3B0aW9uKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkLnNldFNlbGVjdGVkKGZhbHNlLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYXRjaE9wdGlvbi5zZXRTZWxlY3RlZCh0cnVlLCBmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkID0gbWF0Y2hPcHRpb247XG5cbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmFsdWUoZmlyZUV2ZW50cyk7XG4gICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWF0Y2hPcHRpb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgdmFsdWUgcGFyYW1ldGVyIHdpdGggb3B0aW9uYWwgZXZlbnRzLlxuICAgICAqIEBwYXJhbSBmaXJlRXZlbnRzIElmIHRydWUsIGZ1bmN0aW9uIGZpcmVzIHZhbHVlQ2hhbmdlLCBvbkNoYW5nZSBhbmQgb25Ub3VjaGVkIGV2ZW50cy5cbiAgICAgKi9cbiAgICBwcml2YXRlIHVwZGF0ZVZhbHVlKGZpcmVFdmVudHM6IGJvb2xlYW4gPSB0cnVlKTogdm9pZCB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLnNlbGVjdGVkLnZhbHVlO1xuICAgICAgICBpZiAoZmlyZUV2ZW50cykge1xuICAgICAgICAgICAgdGhpcy52YWx1ZUNoYW5nZS5lbWl0KHRoaXMudmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5vbkNoYW5nZSh0aGlzLnZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMub25Ub3VjaGVkKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB1c2VkIHRvIHJlc2V0IHRoZSBvcHRpb25zIHN0YXRlLlxuICAgICAqL1xuICAgIHByaXZhdGUgcmVzZXRPcHRpb25zKCk6IHZvaWQge1xuICAgICAgICAvLyBDcmVhdGUgb2JzZXJ2YWJsZSB0aGF0IGZpcmVzIHdoZW4gdGhlIG9wdGlvbnMgY2hhbmdlIG9yIHRoZSBjb21wb25lbnQgaXMgZGVzdHJveWVkLlxuICAgICAgICBjb25zdCBkZXN0cm95Q3VycmVudE9icyA9IG1lcmdlKHRoaXMub3B0aW9ucy5jaGFuZ2VzLCB0aGlzLmRlc3Ryb3kkKTtcblxuICAgICAgICAvLyBTdWJzY3JpYmUgdG8gb2JzZXJ2YWJsZSBkZWZpbmVkIGluIGNvbXBvbmVudCBwcm9wZXJ0aWVzIHdoaWNoIGZpcmVzIHdoZW4gYW4gb3B0aW9uIGlzIGNsaWNrZWQuXG4gICAgICAgIC8vIERlc3Ryb3kgaWYgdGhlIG9ic2VydmFibGUgZGVmaW5lZCBhYm92ZSB0cmlnZ2Vycy5cbiAgICAgICAgdGhpcy5vcHRpb25zU3RhdHVzQ2hhbmdlcy5waXBlKHRha2VVbnRpbChkZXN0cm95Q3VycmVudE9icykpLnN1YnNjcmliZSgoaW5zdGFuY2U6IE9wdGlvbkNvbXBvbmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RPcHRpb24oaW5zdGFuY2UpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKiogU2VsZWN0aW9uIGluaXRpYWxpemF0aW9uIHdoZW4gYSBjaGFuZ2Ugb2NjdXJzIGluIG9wdGlvbnMuICovXG4gICAgcHJpdmF0ZSBpbml0U2VsZWN0aW9uKCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy52YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0VmFsdWUodGhpcy52YWx1ZSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gdGhhdCB0ZXN0cyB3aGV0aGVyIHRoZSB0ZXN0ZWQgb3B0aW9uIGlzIGN1cnJlbnRseSBzZWxlY3RlZC5cbiAgICAgKiBAcGFyYW0gb3B0aW9uIE9wdGlvbiB0byB0ZXN0IGFnYWluc3QgdGhlIHNlbGVjdGVkIG9wdGlvbi5cbiAgICAgKi9cbiAgICBwcml2YXRlIGlzT3B0aW9uQWN0aXZlKG9wdGlvbjogT3B0aW9uQ29tcG9uZW50KTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiBvcHRpb24gJiYgdGhpcy5zZWxlY3RlZCAmJiBvcHRpb24gPT09IHRoaXMuc2VsZWN0ZWQ7XG4gICAgfVxuXG4gICAgLyoqIE1ldGhvZCB0aGF0IGZvY3VzZXMgdGhlIG5leHQgb3B0aW9uIGluIHRoZSBsaXN0LCBvciB0aGUgZmlyc3Qgb25lIGlmIHRoZSBsYXN0IG9uZSBpcyBjdXJyZW50bHkgZm9jdXNlZC4gKi9cbiAgICBwcml2YXRlIGluY3JlbWVudEZvY3VzZWQoKTogdm9pZCB7XG5cbiAgICAgICAgLy8gR2V0IGFjdGl2ZSBmb2N1c2VkIGVsZW1lbnRcbiAgICAgICAgY29uc3QgYWN0aXZlRWxlbWVudCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG5cbiAgICAgICAgLy8gR2V0IGNvcnJlc3BvbmRpbmcgb3B0aW9uIGVsZW1lbnQgdG8gdGhlIGFib3ZlXG4gICAgICAgIGNvbnN0IGNvcnJlc3BvbmRpbmdPcHRpb24gPSB0aGlzLm9wdGlvbnMuZmluZChvcHRpb24gPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbi5nZXRIdG1sRWxlbWVudCgpID09PSBhY3RpdmVFbGVtZW50O1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoY29ycmVzcG9uZGluZ09wdGlvbikge1xuICAgICAgICAgICAgY29uc3QgYXJyYXlPcHRpb25zID0gdGhpcy5vcHRpb25zLnRvQXJyYXkoKTtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gYXJyYXlPcHRpb25zLmluZGV4T2YoY29ycmVzcG9uZGluZ09wdGlvbik7XG5cbiAgICAgICAgICAgIC8vIElmIGFjdGl2ZSBvcHRpb24gaXMgdGhlIGxhc3Qgb3B0aW9uLCBmb2N1cyB0aGUgZmlyc3Qgb25lXG4gICAgICAgICAgICAvLyBPdGhlcndpc2UsIGZvY3VzIHRoZSBuZXh0IG9wdGlvbi5cbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gdGhpcy5vcHRpb25zLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICBhcnJheU9wdGlvbnNbMF0uZm9jdXMoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYXJyYXlPcHRpb25zW2luZGV4ICsgMV0uZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5maXJzdC5mb2N1cygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIE1ldGhvZCB0aGF0IGZvY3VzZXMgdGhlIHByZXZpb3VzIG9wdGlvbiBpbiB0aGUgbGlzdCwgb3IgdGhlIGxhc3Qgb25lIGlmIHRoZSBsYXN0IG9uZSBpcyBjdXJyZW50bHkgZm9jdXNlZC4gKi9cbiAgICBwcml2YXRlIGRlY3JlbWVudEZvY3VzZWQoKTogdm9pZCB7XG5cbiAgICAgICAgLy8gR2V0IGFjdGl2ZSBmb2N1c2VkIGVsZW1lbnRcbiAgICAgICAgY29uc3QgYWN0aXZlRWxlbWVudCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG5cbiAgICAgICAgLy8gR2V0IGNvcnJlc3BvbmRpbmcgb3B0aW9uIGVsZW1lbnQgdG8gdGhlIGFib3ZlXG4gICAgICAgIGNvbnN0IGNvcnJlc3BvbmRpbmdPcHRpb24gPSB0aGlzLm9wdGlvbnMuZmluZChvcHRpb24gPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbi5nZXRIdG1sRWxlbWVudCgpID09PSBhY3RpdmVFbGVtZW50O1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBJZiBhY3RpdmUgb3B0aW9uIGlzIHRoZSBmaXJzdCBvcHRpb24sIGZvY3VzIHRoZSBsYXN0IG9uZVxuICAgICAgICAvLyBPdGhlcndpc2UsIGZvY3VzIHRoZSBwcmV2aW91cyBvcHRpb24uXG4gICAgICAgIGlmIChjb3JyZXNwb25kaW5nT3B0aW9uKSB7XG4gICAgICAgICAgICBjb25zdCBhcnJheU9wdGlvbnMgPSB0aGlzLm9wdGlvbnMudG9BcnJheSgpO1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBhcnJheU9wdGlvbnMuaW5kZXhPZihjb3JyZXNwb25kaW5nT3B0aW9uKTtcblxuICAgICAgICAgICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgYXJyYXlPcHRpb25zW3RoaXMub3B0aW9ucy5sZW5ndGggLSAxXS5mb2N1cygpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhcnJheU9wdGlvbnNbaW5kZXggLSAxXS5mb2N1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmZpcnN0LmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byBoYW5kbGUgY2FzZXMgd2hlcmUgYSB1c2VyIHJlbW92ZXMgdGhlIGN1cnJlbnRseSBhY3RpdmUgb3B0aW9uLlxuICAgICAqIFRoZSB0aW1lb3V0IGlzIHJlcXVpcmVkIGJlY2F1c2UgdGhpcyBjYW4gaGFwcGVuIGFmdGVyIHRoZSB2aWV3IGhhcyBiZWVuIGNoZWNrZWQuXG4gICAgICovXG4gICAgcHJpdmF0ZSB1bnNlbGVjdE9wdGlvbnMoKTogdm9pZCB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkLnNldFNlbGVjdGVkKGZhbHNlLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMudmFsdWVDaGFuZ2UuZW1pdCh1bmRlZmluZWQpO1xuICAgICAgICAgICAgdGhpcy5vbkNoYW5nZSh1bmRlZmluZWQpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbn1cbiJdfQ==